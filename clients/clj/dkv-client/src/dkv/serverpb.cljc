;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package dkv.serverpb
;;;----------------------------------------------------------------------------------
(ns dkv.serverpb
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->RemoveNodeRequest)
(declare ecis->RemoveNodeRequest)
(declare new-RemoveNodeRequest)
(declare cis->RestoreRequest)
(declare ecis->RestoreRequest)
(declare new-RestoreRequest)
(declare cis->GetResponse)
(declare ecis->GetResponse)
(declare new-GetResponse)
(declare cis->BackupRequest)
(declare ecis->BackupRequest)
(declare new-BackupRequest)
(declare cis->MultiGetRequest)
(declare ecis->MultiGetRequest)
(declare new-MultiGetRequest)
(declare cis->IterateRequest)
(declare ecis->IterateRequest)
(declare new-IterateRequest)
(declare cis->Status)
(declare ecis->Status)
(declare new-Status)
(declare cis->PutResponse)
(declare ecis->PutResponse)
(declare new-PutResponse)
(declare cis->GetRequest)
(declare ecis->GetRequest)
(declare new-GetRequest)
(declare cis->MultiGetResponse)
(declare ecis->MultiGetResponse)
(declare new-MultiGetResponse)
(declare cis->GetChangesResponse)
(declare ecis->GetChangesResponse)
(declare new-GetChangesResponse)
(declare cis->PutRequest)
(declare ecis->PutRequest)
(declare new-PutRequest)
(declare cis->IterateResponse)
(declare ecis->IterateResponse)
(declare new-IterateResponse)
(declare cis->AddNodeRequest)
(declare ecis->AddNodeRequest)
(declare new-AddNodeRequest)
(declare cis->TrxnRecord)
(declare ecis->TrxnRecord)
(declare new-TrxnRecord)
(declare cis->ChangeRecord)
(declare ecis->ChangeRecord)
(declare new-ChangeRecord)
(declare cis->GetChangesRequest)
(declare ecis->GetChangesRequest)
(declare new-GetChangesRequest)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ReadConsistency
;-----------------------------------------------------------------------------
(def ReadConsistency-val2label {
  0 :sequential
  1 :linearizable})

(def ReadConsistency-label2val (set/map-invert ReadConsistency-val2label))

(defn cis->ReadConsistency [is]
  (let [val (serdes.core/cis->Enum is)]
    (get ReadConsistency-val2label val val)))

(defn- get-ReadConsistency [value]
  {:pre [(or (int? value) (contains? ReadConsistency-label2val value))]}
  (get ReadConsistency-label2val value value))

(defn write-ReadConsistency [tag options value os]
  (serdes.core/write-Enum tag options (get-ReadConsistency value) os))

;-----------------------------------------------------------------------------
; TrxnRecord-TrxnType
;-----------------------------------------------------------------------------
(def TrxnRecord-TrxnType-val2label {
  0 :unknown
  1 :put
  2 :delete})

(def TrxnRecord-TrxnType-label2val (set/map-invert TrxnRecord-TrxnType-val2label))

(defn cis->TrxnRecord-TrxnType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get TrxnRecord-TrxnType-val2label val val)))

(defn- get-TrxnRecord-TrxnType [value]
  {:pre [(or (int? value) (contains? TrxnRecord-TrxnType-label2val value))]}
  (get TrxnRecord-TrxnType-label2val value value))

(defn write-TrxnRecord-TrxnType [tag options value os]
  (serdes.core/write-Enum tag options (get-TrxnRecord-TrxnType value) os))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; RemoveNodeRequest
;-----------------------------------------------------------------------------
(defrecord RemoveNodeRequest-record [nodeId]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:nodeId this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.RemoveNodeRequest"))

(s/def :dkv.serverpb.RemoveNodeRequest/nodeId int?)
(s/def ::RemoveNodeRequest-spec (s/keys :opt-un [:dkv.serverpb.RemoveNodeRequest/nodeId ]))
(def RemoveNodeRequest-defaults {:nodeId 0 })

(defn cis->RemoveNodeRequest
  "CodedInputStream to RemoveNodeRequest"
  [is]
  (->> (tag-map RemoveNodeRequest-defaults
         (fn [tag index]
             (case index
               1 [:nodeId (serdes.core/cis->UInt32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RemoveNodeRequest-record)))

(defn ecis->RemoveNodeRequest
  "Embedded CodedInputStream to RemoveNodeRequest"
  [is]
  (serdes.core/cis->embedded cis->RemoveNodeRequest is))

(defn new-RemoveNodeRequest
  "Creates a new instance from a map, similar to map->RemoveNodeRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RemoveNodeRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RemoveNodeRequest-spec init))))]}
  (-> (merge RemoveNodeRequest-defaults init)
      (map->RemoveNodeRequest-record)))

(defn pb->RemoveNodeRequest
  "Protobuf to RemoveNodeRequest"
  [input]
  (cis->RemoveNodeRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RemoveNodeRequest-meta {:type "dkv.serverpb.RemoveNodeRequest" :decoder pb->RemoveNodeRequest})

;-----------------------------------------------------------------------------
; RestoreRequest
;-----------------------------------------------------------------------------
(defrecord RestoreRequest-record [restorePath]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:restorePath this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.RestoreRequest"))

(s/def :dkv.serverpb.RestoreRequest/restorePath string?)
(s/def ::RestoreRequest-spec (s/keys :opt-un [:dkv.serverpb.RestoreRequest/restorePath ]))
(def RestoreRequest-defaults {:restorePath "" })

(defn cis->RestoreRequest
  "CodedInputStream to RestoreRequest"
  [is]
  (->> (tag-map RestoreRequest-defaults
         (fn [tag index]
             (case index
               1 [:restorePath (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->RestoreRequest-record)))

(defn ecis->RestoreRequest
  "Embedded CodedInputStream to RestoreRequest"
  [is]
  (serdes.core/cis->embedded cis->RestoreRequest is))

(defn new-RestoreRequest
  "Creates a new instance from a map, similar to map->RestoreRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::RestoreRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::RestoreRequest-spec init))))]}
  (-> (merge RestoreRequest-defaults init)
      (map->RestoreRequest-record)))

(defn pb->RestoreRequest
  "Protobuf to RestoreRequest"
  [input]
  (cis->RestoreRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record RestoreRequest-meta {:type "dkv.serverpb.RestoreRequest" :decoder pb->RestoreRequest})

;-----------------------------------------------------------------------------
; GetResponse
;-----------------------------------------------------------------------------
(defrecord GetResponse-record [status value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:status this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.GetResponse"))

(s/def :dkv.serverpb.GetResponse/value bytes?)
(s/def ::GetResponse-spec (s/keys :opt-un [:dkv.serverpb.GetResponse/value ]))
(def GetResponse-defaults {:value (byte-array 0) })

(defn cis->GetResponse
  "CodedInputStream to GetResponse"
  [is]
  (->> (tag-map GetResponse-defaults
         (fn [tag index]
             (case index
               1 [:status (ecis->Status is)]
               2 [:value (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GetResponse-record)))

(defn ecis->GetResponse
  "Embedded CodedInputStream to GetResponse"
  [is]
  (serdes.core/cis->embedded cis->GetResponse is))

(defn new-GetResponse
  "Creates a new instance from a map, similar to map->GetResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GetResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GetResponse-spec init))))]}
  (-> (merge GetResponse-defaults init)
      (cond-> (contains? init :status) (update :status new-Status))
      (map->GetResponse-record)))

(defn pb->GetResponse
  "Protobuf to GetResponse"
  [input]
  (cis->GetResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GetResponse-meta {:type "dkv.serverpb.GetResponse" :decoder pb->GetResponse})

;-----------------------------------------------------------------------------
; BackupRequest
;-----------------------------------------------------------------------------
(defrecord BackupRequest-record [backupPath]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:backupPath this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.BackupRequest"))

(s/def :dkv.serverpb.BackupRequest/backupPath string?)
(s/def ::BackupRequest-spec (s/keys :opt-un [:dkv.serverpb.BackupRequest/backupPath ]))
(def BackupRequest-defaults {:backupPath "" })

(defn cis->BackupRequest
  "CodedInputStream to BackupRequest"
  [is]
  (->> (tag-map BackupRequest-defaults
         (fn [tag index]
             (case index
               1 [:backupPath (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->BackupRequest-record)))

(defn ecis->BackupRequest
  "Embedded CodedInputStream to BackupRequest"
  [is]
  (serdes.core/cis->embedded cis->BackupRequest is))

(defn new-BackupRequest
  "Creates a new instance from a map, similar to map->BackupRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BackupRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BackupRequest-spec init))))]}
  (-> (merge BackupRequest-defaults init)
      (map->BackupRequest-record)))

(defn pb->BackupRequest
  "Protobuf to BackupRequest"
  [input]
  (cis->BackupRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record BackupRequest-meta {:type "dkv.serverpb.BackupRequest" :decoder pb->BackupRequest})

;-----------------------------------------------------------------------------
; MultiGetRequest
;-----------------------------------------------------------------------------
(defrecord MultiGetRequest-record [keys readConsistency]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-Bytes 1 (:keys this) os)
    (write-ReadConsistency 2  {:optimize true} (:readConsistency this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.MultiGetRequest"))

(s/def :dkv.serverpb.MultiGetRequest/keys (s/every bytes?))
(s/def :dkv.serverpb.MultiGetRequest/readConsistency (s/or :keyword keyword? :int int?))
(s/def ::MultiGetRequest-spec (s/keys :opt-un [:dkv.serverpb.MultiGetRequest/keys :dkv.serverpb.MultiGetRequest/readConsistency ]))
(def MultiGetRequest-defaults {:keys [] :readConsistency (ReadConsistency-val2label 0) })

(defn cis->MultiGetRequest
  "CodedInputStream to MultiGetRequest"
  [is]
  (->> (tag-map MultiGetRequest-defaults
         (fn [tag index]
             (case index
               1 [:keys (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]
               2 [:readConsistency (cis->ReadConsistency is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MultiGetRequest-record)))

(defn ecis->MultiGetRequest
  "Embedded CodedInputStream to MultiGetRequest"
  [is]
  (serdes.core/cis->embedded cis->MultiGetRequest is))

(defn new-MultiGetRequest
  "Creates a new instance from a map, similar to map->MultiGetRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MultiGetRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MultiGetRequest-spec init))))]}
  (-> (merge MultiGetRequest-defaults init)
      (map->MultiGetRequest-record)))

(defn pb->MultiGetRequest
  "Protobuf to MultiGetRequest"
  [input]
  (cis->MultiGetRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MultiGetRequest-meta {:type "dkv.serverpb.MultiGetRequest" :decoder pb->MultiGetRequest})

;-----------------------------------------------------------------------------
; IterateRequest
;-----------------------------------------------------------------------------
(defrecord IterateRequest-record [keyPrefix startKey]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:keyPrefix this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:startKey this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.IterateRequest"))

(s/def :dkv.serverpb.IterateRequest/keyPrefix bytes?)
(s/def :dkv.serverpb.IterateRequest/startKey bytes?)
(s/def ::IterateRequest-spec (s/keys :opt-un [:dkv.serverpb.IterateRequest/keyPrefix :dkv.serverpb.IterateRequest/startKey ]))
(def IterateRequest-defaults {:keyPrefix (byte-array 0) :startKey (byte-array 0) })

(defn cis->IterateRequest
  "CodedInputStream to IterateRequest"
  [is]
  (->> (tag-map IterateRequest-defaults
         (fn [tag index]
             (case index
               1 [:keyPrefix (serdes.core/cis->Bytes is)]
               2 [:startKey (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->IterateRequest-record)))

(defn ecis->IterateRequest
  "Embedded CodedInputStream to IterateRequest"
  [is]
  (serdes.core/cis->embedded cis->IterateRequest is))

(defn new-IterateRequest
  "Creates a new instance from a map, similar to map->IterateRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::IterateRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::IterateRequest-spec init))))]}
  (-> (merge IterateRequest-defaults init)
      (map->IterateRequest-record)))

(defn pb->IterateRequest
  "Protobuf to IterateRequest"
  [input]
  (cis->IterateRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record IterateRequest-meta {:type "dkv.serverpb.IterateRequest" :decoder pb->IterateRequest})

;-----------------------------------------------------------------------------
; Status
;-----------------------------------------------------------------------------
(defrecord Status-record [code message]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Int32 1  {:optimize true} (:code this) os)
    (serdes.core/write-String 2  {:optimize true} (:message this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.Status"))

(s/def :dkv.serverpb.Status/code int?)
(s/def :dkv.serverpb.Status/message string?)
(s/def ::Status-spec (s/keys :opt-un [:dkv.serverpb.Status/code :dkv.serverpb.Status/message ]))
(def Status-defaults {:code 0 :message "" })

(defn cis->Status
  "CodedInputStream to Status"
  [is]
  (->> (tag-map Status-defaults
         (fn [tag index]
             (case index
               1 [:code (serdes.core/cis->Int32 is)]
               2 [:message (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Status-record)))

(defn ecis->Status
  "Embedded CodedInputStream to Status"
  [is]
  (serdes.core/cis->embedded cis->Status is))

(defn new-Status
  "Creates a new instance from a map, similar to map->Status except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Status-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Status-spec init))))]}
  (-> (merge Status-defaults init)
      (map->Status-record)))

(defn pb->Status
  "Protobuf to Status"
  [input]
  (cis->Status (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Status-meta {:type "dkv.serverpb.Status" :decoder pb->Status})

;-----------------------------------------------------------------------------
; PutResponse
;-----------------------------------------------------------------------------
(defrecord PutResponse-record [status]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:status this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.PutResponse"))

(s/def ::PutResponse-spec (s/keys :opt-un []))
(def PutResponse-defaults {})

(defn cis->PutResponse
  "CodedInputStream to PutResponse"
  [is]
  (->> (tag-map PutResponse-defaults
         (fn [tag index]
             (case index
               1 [:status (ecis->Status is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PutResponse-record)))

(defn ecis->PutResponse
  "Embedded CodedInputStream to PutResponse"
  [is]
  (serdes.core/cis->embedded cis->PutResponse is))

(defn new-PutResponse
  "Creates a new instance from a map, similar to map->PutResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutResponse-spec init))))]}
  (-> (merge PutResponse-defaults init)
      (cond-> (contains? init :status) (update :status new-Status))
      (map->PutResponse-record)))

(defn pb->PutResponse
  "Protobuf to PutResponse"
  [input]
  (cis->PutResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PutResponse-meta {:type "dkv.serverpb.PutResponse" :decoder pb->PutResponse})

;-----------------------------------------------------------------------------
; GetRequest
;-----------------------------------------------------------------------------
(defrecord GetRequest-record [key readConsistency]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:key this) os)
    (write-ReadConsistency 2  {:optimize true} (:readConsistency this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.GetRequest"))

(s/def :dkv.serverpb.GetRequest/key bytes?)
(s/def :dkv.serverpb.GetRequest/readConsistency (s/or :keyword keyword? :int int?))
(s/def ::GetRequest-spec (s/keys :opt-un [:dkv.serverpb.GetRequest/key :dkv.serverpb.GetRequest/readConsistency ]))
(def GetRequest-defaults {:key (byte-array 0) :readConsistency (ReadConsistency-val2label 0) })

(defn cis->GetRequest
  "CodedInputStream to GetRequest"
  [is]
  (->> (tag-map GetRequest-defaults
         (fn [tag index]
             (case index
               1 [:key (serdes.core/cis->Bytes is)]
               2 [:readConsistency (cis->ReadConsistency is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GetRequest-record)))

(defn ecis->GetRequest
  "Embedded CodedInputStream to GetRequest"
  [is]
  (serdes.core/cis->embedded cis->GetRequest is))

(defn new-GetRequest
  "Creates a new instance from a map, similar to map->GetRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GetRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GetRequest-spec init))))]}
  (-> (merge GetRequest-defaults init)
      (map->GetRequest-record)))

(defn pb->GetRequest
  "Protobuf to GetRequest"
  [input]
  (cis->GetRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GetRequest-meta {:type "dkv.serverpb.GetRequest" :decoder pb->GetRequest})

;-----------------------------------------------------------------------------
; MultiGetResponse
;-----------------------------------------------------------------------------
(defrecord MultiGetResponse-record [values]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-Bytes 2 (:values this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.MultiGetResponse"))

(s/def :dkv.serverpb.MultiGetResponse/values (s/every bytes?))
(s/def ::MultiGetResponse-spec (s/keys :opt-un [:dkv.serverpb.MultiGetResponse/values ]))
(def MultiGetResponse-defaults {:values [] })

(defn cis->MultiGetResponse
  "CodedInputStream to MultiGetResponse"
  [is]
  (->> (tag-map MultiGetResponse-defaults
         (fn [tag index]
             (case index
               2 [:values (serdes.complex/cis->repeated serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->MultiGetResponse-record)))

(defn ecis->MultiGetResponse
  "Embedded CodedInputStream to MultiGetResponse"
  [is]
  (serdes.core/cis->embedded cis->MultiGetResponse is))

(defn new-MultiGetResponse
  "Creates a new instance from a map, similar to map->MultiGetResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MultiGetResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MultiGetResponse-spec init))))]}
  (-> (merge MultiGetResponse-defaults init)
      (cond-> (contains? init :status) (update :status new-Status))
      (map->MultiGetResponse-record)))

(defn pb->MultiGetResponse
  "Protobuf to MultiGetResponse"
  [input]
  (cis->MultiGetResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record MultiGetResponse-meta {:type "dkv.serverpb.MultiGetResponse" :decoder pb->MultiGetResponse})

;-----------------------------------------------------------------------------
; GetChangesResponse
;-----------------------------------------------------------------------------
(defrecord GetChangesResponse-record [status masterChangeNumber numberOfChanges changes]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:status this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:masterChangeNumber this) os)
    (serdes.core/write-UInt32 3  {:optimize true} (:numberOfChanges this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:changes this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.GetChangesResponse"))

(s/def :dkv.serverpb.GetChangesResponse/masterChangeNumber int?)
(s/def :dkv.serverpb.GetChangesResponse/numberOfChanges int?)

(s/def ::GetChangesResponse-spec (s/keys :opt-un [:dkv.serverpb.GetChangesResponse/masterChangeNumber :dkv.serverpb.GetChangesResponse/numberOfChanges ]))
(def GetChangesResponse-defaults {:masterChangeNumber 0 :numberOfChanges 0 :changes [] })

(defn cis->GetChangesResponse
  "CodedInputStream to GetChangesResponse"
  [is]
  (->> (tag-map GetChangesResponse-defaults
         (fn [tag index]
             (case index
               1 [:status (ecis->Status is)]
               2 [:masterChangeNumber (serdes.core/cis->UInt64 is)]
               3 [:numberOfChanges (serdes.core/cis->UInt32 is)]
               4 [:changes (serdes.complex/cis->repeated ecis->ChangeRecord is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GetChangesResponse-record)))

(defn ecis->GetChangesResponse
  "Embedded CodedInputStream to GetChangesResponse"
  [is]
  (serdes.core/cis->embedded cis->GetChangesResponse is))

(defn new-GetChangesResponse
  "Creates a new instance from a map, similar to map->GetChangesResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GetChangesResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GetChangesResponse-spec init))))]}
  (-> (merge GetChangesResponse-defaults init)
      (cond-> (contains? init :status) (update :status new-Status))
      (cond-> (contains? init :changes) (update :changes #(map new-ChangeRecord %)))
      (map->GetChangesResponse-record)))

(defn pb->GetChangesResponse
  "Protobuf to GetChangesResponse"
  [input]
  (cis->GetChangesResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GetChangesResponse-meta {:type "dkv.serverpb.GetChangesResponse" :decoder pb->GetChangesResponse})

;-----------------------------------------------------------------------------
; PutRequest
;-----------------------------------------------------------------------------
(defrecord PutRequest-record [key value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.PutRequest"))

(s/def :dkv.serverpb.PutRequest/key bytes?)
(s/def :dkv.serverpb.PutRequest/value bytes?)
(s/def ::PutRequest-spec (s/keys :opt-un [:dkv.serverpb.PutRequest/key :dkv.serverpb.PutRequest/value ]))
(def PutRequest-defaults {:key (byte-array 0) :value (byte-array 0) })

(defn cis->PutRequest
  "CodedInputStream to PutRequest"
  [is]
  (->> (tag-map PutRequest-defaults
         (fn [tag index]
             (case index
               1 [:key (serdes.core/cis->Bytes is)]
               2 [:value (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->PutRequest-record)))

(defn ecis->PutRequest
  "Embedded CodedInputStream to PutRequest"
  [is]
  (serdes.core/cis->embedded cis->PutRequest is))

(defn new-PutRequest
  "Creates a new instance from a map, similar to map->PutRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutRequest-spec init))))]}
  (-> (merge PutRequest-defaults init)
      (map->PutRequest-record)))

(defn pb->PutRequest
  "Protobuf to PutRequest"
  [input]
  (cis->PutRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PutRequest-meta {:type "dkv.serverpb.PutRequest" :decoder pb->PutRequest})

;-----------------------------------------------------------------------------
; IterateResponse
;-----------------------------------------------------------------------------
(defrecord IterateResponse-record [status key value]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:status this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.IterateResponse"))

(s/def :dkv.serverpb.IterateResponse/key bytes?)
(s/def :dkv.serverpb.IterateResponse/value bytes?)
(s/def ::IterateResponse-spec (s/keys :opt-un [:dkv.serverpb.IterateResponse/key :dkv.serverpb.IterateResponse/value ]))
(def IterateResponse-defaults {:key (byte-array 0) :value (byte-array 0) })

(defn cis->IterateResponse
  "CodedInputStream to IterateResponse"
  [is]
  (->> (tag-map IterateResponse-defaults
         (fn [tag index]
             (case index
               1 [:status (ecis->Status is)]
               2 [:key (serdes.core/cis->Bytes is)]
               3 [:value (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->IterateResponse-record)))

(defn ecis->IterateResponse
  "Embedded CodedInputStream to IterateResponse"
  [is]
  (serdes.core/cis->embedded cis->IterateResponse is))

(defn new-IterateResponse
  "Creates a new instance from a map, similar to map->IterateResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::IterateResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::IterateResponse-spec init))))]}
  (-> (merge IterateResponse-defaults init)
      (cond-> (contains? init :status) (update :status new-Status))
      (map->IterateResponse-record)))

(defn pb->IterateResponse
  "Protobuf to IterateResponse"
  [input]
  (cis->IterateResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record IterateResponse-meta {:type "dkv.serverpb.IterateResponse" :decoder pb->IterateResponse})

;-----------------------------------------------------------------------------
; AddNodeRequest
;-----------------------------------------------------------------------------
(defrecord AddNodeRequest-record [nodeId nodeUrl]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt32 1  {:optimize true} (:nodeId this) os)
    (serdes.core/write-String 2  {:optimize true} (:nodeUrl this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.AddNodeRequest"))

(s/def :dkv.serverpb.AddNodeRequest/nodeId int?)
(s/def :dkv.serverpb.AddNodeRequest/nodeUrl string?)
(s/def ::AddNodeRequest-spec (s/keys :opt-un [:dkv.serverpb.AddNodeRequest/nodeId :dkv.serverpb.AddNodeRequest/nodeUrl ]))
(def AddNodeRequest-defaults {:nodeId 0 :nodeUrl "" })

(defn cis->AddNodeRequest
  "CodedInputStream to AddNodeRequest"
  [is]
  (->> (tag-map AddNodeRequest-defaults
         (fn [tag index]
             (case index
               1 [:nodeId (serdes.core/cis->UInt32 is)]
               2 [:nodeUrl (serdes.core/cis->String is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->AddNodeRequest-record)))

(defn ecis->AddNodeRequest
  "Embedded CodedInputStream to AddNodeRequest"
  [is]
  (serdes.core/cis->embedded cis->AddNodeRequest is))

(defn new-AddNodeRequest
  "Creates a new instance from a map, similar to map->AddNodeRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::AddNodeRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::AddNodeRequest-spec init))))]}
  (-> (merge AddNodeRequest-defaults init)
      (map->AddNodeRequest-record)))

(defn pb->AddNodeRequest
  "Protobuf to AddNodeRequest"
  [input]
  (cis->AddNodeRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record AddNodeRequest-meta {:type "dkv.serverpb.AddNodeRequest" :decoder pb->AddNodeRequest})

;-----------------------------------------------------------------------------
; TrxnRecord
;-----------------------------------------------------------------------------
(defrecord TrxnRecord-record [type key value]
  pb/Writer
  (serialize [this os]
    (write-TrxnRecord-TrxnType 1  {:optimize true} (:type this) os)
    (serdes.core/write-Bytes 2  {:optimize true} (:key this) os)
    (serdes.core/write-Bytes 3  {:optimize true} (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.TrxnRecord"))

(s/def :dkv.serverpb.TrxnRecord/type (s/or :keyword keyword? :int int?))
(s/def :dkv.serverpb.TrxnRecord/key bytes?)
(s/def :dkv.serverpb.TrxnRecord/value bytes?)
(s/def ::TrxnRecord-spec (s/keys :opt-un [:dkv.serverpb.TrxnRecord/type :dkv.serverpb.TrxnRecord/key :dkv.serverpb.TrxnRecord/value ]))
(def TrxnRecord-defaults {:type (TrxnRecord-TrxnType-val2label 0) :key (byte-array 0) :value (byte-array 0) })

(defn cis->TrxnRecord
  "CodedInputStream to TrxnRecord"
  [is]
  (->> (tag-map TrxnRecord-defaults
         (fn [tag index]
             (case index
               1 [:type (cis->TrxnRecord-TrxnType is)]
               2 [:key (serdes.core/cis->Bytes is)]
               3 [:value (serdes.core/cis->Bytes is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->TrxnRecord-record)))

(defn ecis->TrxnRecord
  "Embedded CodedInputStream to TrxnRecord"
  [is]
  (serdes.core/cis->embedded cis->TrxnRecord is))

(defn new-TrxnRecord
  "Creates a new instance from a map, similar to map->TrxnRecord except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::TrxnRecord-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::TrxnRecord-spec init))))]}
  (-> (merge TrxnRecord-defaults init)
      (map->TrxnRecord-record)))

(defn pb->TrxnRecord
  "Protobuf to TrxnRecord"
  [input]
  (cis->TrxnRecord (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record TrxnRecord-meta {:type "dkv.serverpb.TrxnRecord" :decoder pb->TrxnRecord})

;-----------------------------------------------------------------------------
; ChangeRecord
;-----------------------------------------------------------------------------
(defrecord ChangeRecord-record [serialisedForm changeNumber numberOfTrxns trxns]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-Bytes 1  {:optimize true} (:serialisedForm this) os)
    (serdes.core/write-UInt64 2  {:optimize true} (:changeNumber this) os)
    (serdes.core/write-UInt32 3  {:optimize true} (:numberOfTrxns this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 4 (:trxns this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.ChangeRecord"))

(s/def :dkv.serverpb.ChangeRecord/serialisedForm bytes?)
(s/def :dkv.serverpb.ChangeRecord/changeNumber int?)
(s/def :dkv.serverpb.ChangeRecord/numberOfTrxns int?)

(s/def ::ChangeRecord-spec (s/keys :opt-un [:dkv.serverpb.ChangeRecord/serialisedForm :dkv.serverpb.ChangeRecord/changeNumber :dkv.serverpb.ChangeRecord/numberOfTrxns ]))
(def ChangeRecord-defaults {:serialisedForm (byte-array 0) :changeNumber 0 :numberOfTrxns 0 :trxns [] })

(defn cis->ChangeRecord
  "CodedInputStream to ChangeRecord"
  [is]
  (->> (tag-map ChangeRecord-defaults
         (fn [tag index]
             (case index
               1 [:serialisedForm (serdes.core/cis->Bytes is)]
               2 [:changeNumber (serdes.core/cis->UInt64 is)]
               3 [:numberOfTrxns (serdes.core/cis->UInt32 is)]
               4 [:trxns (serdes.complex/cis->repeated ecis->TrxnRecord is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->ChangeRecord-record)))

(defn ecis->ChangeRecord
  "Embedded CodedInputStream to ChangeRecord"
  [is]
  (serdes.core/cis->embedded cis->ChangeRecord is))

(defn new-ChangeRecord
  "Creates a new instance from a map, similar to map->ChangeRecord except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ChangeRecord-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ChangeRecord-spec init))))]}
  (-> (merge ChangeRecord-defaults init)
      (cond-> (contains? init :trxns) (update :trxns #(map new-TrxnRecord %)))
      (map->ChangeRecord-record)))

(defn pb->ChangeRecord
  "Protobuf to ChangeRecord"
  [input]
  (cis->ChangeRecord (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record ChangeRecord-meta {:type "dkv.serverpb.ChangeRecord" :decoder pb->ChangeRecord})

;-----------------------------------------------------------------------------
; GetChangesRequest
;-----------------------------------------------------------------------------
(defrecord GetChangesRequest-record [fromChangeNumber maxNumberOfChanges]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-UInt64 1  {:optimize true} (:fromChangeNumber this) os)
    (serdes.core/write-UInt32 2  {:optimize true} (:maxNumberOfChanges this) os))
  pb/TypeReflection
  (gettype [this]
    "dkv.serverpb.GetChangesRequest"))

(s/def :dkv.serverpb.GetChangesRequest/fromChangeNumber int?)
(s/def :dkv.serverpb.GetChangesRequest/maxNumberOfChanges int?)
(s/def ::GetChangesRequest-spec (s/keys :opt-un [:dkv.serverpb.GetChangesRequest/fromChangeNumber :dkv.serverpb.GetChangesRequest/maxNumberOfChanges ]))
(def GetChangesRequest-defaults {:fromChangeNumber 0 :maxNumberOfChanges 0 })

(defn cis->GetChangesRequest
  "CodedInputStream to GetChangesRequest"
  [is]
  (->> (tag-map GetChangesRequest-defaults
         (fn [tag index]
             (case index
               1 [:fromChangeNumber (serdes.core/cis->UInt64 is)]
               2 [:maxNumberOfChanges (serdes.core/cis->UInt32 is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->GetChangesRequest-record)))

(defn ecis->GetChangesRequest
  "Embedded CodedInputStream to GetChangesRequest"
  [is]
  (serdes.core/cis->embedded cis->GetChangesRequest is))

(defn new-GetChangesRequest
  "Creates a new instance from a map, similar to map->GetChangesRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GetChangesRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GetChangesRequest-spec init))))]}
  (-> (merge GetChangesRequest-defaults init)
      (map->GetChangesRequest-record)))

(defn pb->GetChangesRequest
  "Protobuf to GetChangesRequest"
  [input]
  (cis->GetChangesRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record GetChangesRequest-meta {:type "dkv.serverpb.GetChangesRequest" :decoder pb->GetChangesRequest})

